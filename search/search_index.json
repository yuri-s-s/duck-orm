{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DuckORM The Duck-ORM package is an asynchronous ORM for Python, with support for Postgres and SQLite . ORM is built with: databases Requirements : Python 3.8+ Duck-ORM is still under development . Installation 1 $ pip install duck-orm Note Don't forget to install databases before installing duck-orm . Quickstart For this example we will create a connection to the SQLite database and create a model. 1 2 $ pip install databases [ sqlite ] $ pip install ipython Note that we want to use ipython here, because it supports using await expressions directly from the console. Creating the connection to the SQLite database: 1 2 3 4 5 from databases import Database from duck_orm.Model import Model db = Database ( 'sqlite:///example.db' ) await db . connect () Defining a model: 1 2 3 4 5 6 7 8 9 10 11 12 13 from duck_orm.sql import fields as Field class Person ( Model ): __tablename__ = 'persons' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger ( min_value = 18 ) # Table creation in the database. await Person . create () The __tablename__ attribute is used to define the table's name in the database. The __db__ attribute is the instance of the database connection. And then the definition of the fields, their types and restrictions. And finally, the table creation in the database. License DuckORM is built as an open-source tool and remains completely free(MIT license).","title":"Introduction"},{"location":"#duckorm","text":"The Duck-ORM package is an asynchronous ORM for Python, with support for Postgres and SQLite . ORM is built with: databases Requirements : Python 3.8+ Duck-ORM is still under development .","title":"DuckORM"},{"location":"#installation","text":"1 $ pip install duck-orm Note Don't forget to install databases before installing duck-orm .","title":"Installation"},{"location":"#quickstart","text":"For this example we will create a connection to the SQLite database and create a model. 1 2 $ pip install databases [ sqlite ] $ pip install ipython Note that we want to use ipython here, because it supports using await expressions directly from the console.","title":"Quickstart"},{"location":"#creating-the-connection-to-the-sqlite-database","text":"1 2 3 4 5 from databases import Database from duck_orm.Model import Model db = Database ( 'sqlite:///example.db' ) await db . connect ()","title":"Creating the connection to the SQLite database:"},{"location":"#defining-a-model","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 from duck_orm.sql import fields as Field class Person ( Model ): __tablename__ = 'persons' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger ( min_value = 18 ) # Table creation in the database. await Person . create () The __tablename__ attribute is used to define the table's name in the database. The __db__ attribute is the instance of the database connection. And then the definition of the fields, their types and restrictions. And finally, the table creation in the database.","title":"Defining a model:"},{"location":"#license","text":"DuckORM is built as an open-source tool and remains completely free(MIT license).","title":"License"},{"location":"getting_started/","text":"Getting Started Installation 1 pip install duck-orm Dependencies DuckORM uses databases for database connection. Extras dependencies DuckORM can have up to 3 dependencies according to the backend database(s) you want to use: Postgresql 1 pip install duck-orm [ postgresql ] Will install also asyncpg . Postgresql + aiopg 1 pip install duck-orm [ postgresql+aiopg ] Will install also aiopg . SQLite 1 pip install duck-orm [ sqlite ] Will install also aiosqlite . Install dependencies manually If you wish, you can install the dependencies manually as well. Example: 1 pip install asyncpg","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"getting_started/#installation","text":"1 pip install duck-orm","title":"Installation"},{"location":"getting_started/#dependencies","text":"DuckORM uses databases for database connection.","title":"Dependencies"},{"location":"getting_started/#extras-dependencies","text":"DuckORM can have up to 3 dependencies according to the backend database(s) you want to use:","title":"Extras dependencies"},{"location":"getting_started/#postgresql","text":"1 pip install duck-orm [ postgresql ] Will install also asyncpg .","title":"Postgresql"},{"location":"getting_started/#postgresql-aiopg","text":"1 pip install duck-orm [ postgresql+aiopg ] Will install also aiopg .","title":"Postgresql + aiopg"},{"location":"getting_started/#sqlite","text":"1 pip install duck-orm [ sqlite ] Will install also aiosqlite .","title":"SQLite"},{"location":"getting_started/#install-dependencies-manually","text":"If you wish, you can install the dependencies manually as well. Example: 1 pip install asyncpg","title":"Install dependencies manually"},{"location":"fields/","text":"Fields So far we only have 5 types available and 5 special types: ForeignKey , OneToMany , OneToOne and ManyToMany . These special types are for relationships between database tables. Tip For more details on relationship fields, see here Common Types: String 1 2 3 4 String ( unique : bool = False , primary_key : bool = False , not_null : bool = False , default_value = None ) Type in database postgres: TEXT Type in database sqlite: TEXT Type: str Integer 1 2 3 4 Integer ( min_value : int = None , unique : bool = False , primary_key : bool = False , auto_increment : bool = False , not_null : bool = False , default_value = None ) Type in database postgres: INTEGER Type in database sqlite: INTEGER Type: int BigInteger 1 2 3 BigInteger ( unique : bool = False , primary_key : bool = False , default_value = None ) Type in database postgres: BIGINT Type in database sqlite: BIGINT Type: int Varchar 1 2 3 4 Varchar ( length : int , unique : bool = False , primary_key : bool = False , default_value = None ) Type in database postgres: VARCHAR Type in database sqlite: VARCHAR Type: str Boolean 1 Boolean ( not_null : bool = False , default_value = None ) Type in database postgres: BOOLEAN Type in database sqlite: INTEGER Type: bool","title":"Field Types"},{"location":"fields/#fields","text":"So far we only have 5 types available and 5 special types: ForeignKey , OneToMany , OneToOne and ManyToMany . These special types are for relationships between database tables. Tip For more details on relationship fields, see here","title":"Fields"},{"location":"fields/#common-types","text":"","title":"Common Types:"},{"location":"fields/#string","text":"1 2 3 4 String ( unique : bool = False , primary_key : bool = False , not_null : bool = False , default_value = None ) Type in database postgres: TEXT Type in database sqlite: TEXT Type: str","title":"String"},{"location":"fields/#integer","text":"1 2 3 4 Integer ( min_value : int = None , unique : bool = False , primary_key : bool = False , auto_increment : bool = False , not_null : bool = False , default_value = None ) Type in database postgres: INTEGER Type in database sqlite: INTEGER Type: int","title":"Integer"},{"location":"fields/#biginteger","text":"1 2 3 BigInteger ( unique : bool = False , primary_key : bool = False , default_value = None ) Type in database postgres: BIGINT Type in database sqlite: BIGINT Type: int","title":"BigInteger"},{"location":"fields/#varchar","text":"1 2 3 4 Varchar ( length : int , unique : bool = False , primary_key : bool = False , default_value = None ) Type in database postgres: VARCHAR Type in database sqlite: VARCHAR Type: str","title":"Varchar"},{"location":"fields/#boolean","text":"1 Boolean ( not_null : bool = False , default_value = None ) Type in database postgres: BOOLEAN Type in database sqlite: INTEGER Type: bool","title":"Boolean"},{"location":"fields/foreignkey/","text":"ForeignKey This field is to represent the Foreign Key. Let's look at some methods this field allows. The interface of a field ForeignKey : 1 ForeignKey ( model : Type [ Model ], name_in_table_fk : str , unique : bool = False ): Parameters: model : The Model that will be used in the relationship. name_in_table_fk : The name of the attribute that will be FK in the other model. unique : Whether this field is going to be a single value or not. Examples Since this field is used to create some types of relationships, the examples of use of this field can be found in the documentation on OneToMany and ManyToMany .","title":"ForeignKey"},{"location":"fields/foreignkey/#foreignkey","text":"This field is to represent the Foreign Key. Let's look at some methods this field allows. The interface of a field ForeignKey : 1 ForeignKey ( model : Type [ Model ], name_in_table_fk : str , unique : bool = False ): Parameters: model : The Model that will be used in the relationship. name_in_table_fk : The name of the attribute that will be FK in the other model. unique : Whether this field is going to be a single value or not.","title":"ForeignKey"},{"location":"fields/foreignkey/#examples","text":"Since this field is used to create some types of relationships, the examples of use of this field can be found in the documentation on OneToMany and ManyToMany .","title":"Examples"},{"location":"fields/many_to_many/","text":"ManyToMany This field should represent the Many to Many relationship. Let's look at some methods allowed by this field. The interface of a field ManyToMany : 1 ManyToMany ( model : Model , model_relation : Model ): Parameters: model : The other Model that will be used in the relationship. model_relation : The Model that represents the relationship table between the two models. Methods Methods that are supported by the ManyToMany field. add_models Takes instance of the two relationship models and then saves it to the relationship table. 1 2 async def add_models ( model_instance_one : Model , model_instance_two : Model ) -> Model : Parameters: model_instance_one : An instance of the Model of the relation. model_instance_two : An instance of the main Model that calls the method. add Method called from an instance of one model and you must pass the instance of the other model. The relationship between the two will be saved. 1 async def add ( model_instance_one : Model ) -> Model : Parameters: model_instance_one : An instance of the Model of the relation. get_all Returns records from the other model of the relationship. 1 async def get_all () -> list [ Model ]: Examples First, let's create our templates. Examples of using the methods explained above. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class User ( Model ): __tablename__ = 'users' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) name : str = Field . String () @classmethod def relationships ( cls ): cls . working_day = ManyToMany ( model = WorkingDay , model_relation = UsersWorkingDay ) class WorkingDay ( Model ): __tablename__ = 'working_days' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) week_day : str = Field . String () working_date : str = Field . String () @classmethod def relationships ( cls ): cls . users = ManyToMany ( model = User , model_relation = UsersWorkingDay ) class UsersWorkingDay ( Model ): __tablename__ = 'users_working_days' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) users : User = ForeignKey ( model = User , name_in_table_fk = 'id' ) working_days : WorkingDay = ForeignKey ( model = WorkingDay , name_in_table_fk = 'id' ) await User . create () await WorkingDay . create () await UsersWorkingDay . create () Can I use the Add and/or add_models method of the ManyToMany field to save a relationship: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 user = await User . save ( User ( name = 'Rich' )) user1 = await User . save ( User ( name = 'Elton' )) working_day = WorkingDay ( week_day = 'segunda' , working_date = '02/08/2021' ) working_day1 = WorkingDay ( week_day = 'ter\u00e7a' , working_date = '03/08/2021' ) working_day = await WorkingDay . save ( working_day ) working_day1 = await WorkingDay . save ( working_day1 ) await User . working_day . add_models ( working_day , user ) await WorkingDay . users . add_models ( user , working_day1 ) await user1 . working_day . add ( working_day ) await user1 . working_day . add ( working_day1 ) In lines 10, 11, 13 and 14 we are creating a record in the table UsersWorkingDay which is responsible for the Many to Many relationship. Do you notice a difference between lines 10-11 and 13-14? In the first ones it uses the attribute that is not only on the instance, it calls the from the models themselves, User and WorkingDay . In the last two it uses the instance attribute of a User , so it uses this instance to save in the relationship with the record that is passed as parameter. We also have the get_all method: 1 2 3 4 5 users : list [ User ] = await working_day . users . get_all () for u in users : print ( u . id ) # 1 and 2 print ( u . name ) # 'Rich' and 'Elton'","title":"ManyToMany"},{"location":"fields/many_to_many/#manytomany","text":"This field should represent the Many to Many relationship. Let's look at some methods allowed by this field. The interface of a field ManyToMany : 1 ManyToMany ( model : Model , model_relation : Model ): Parameters: model : The other Model that will be used in the relationship. model_relation : The Model that represents the relationship table between the two models.","title":"ManyToMany"},{"location":"fields/many_to_many/#methods","text":"Methods that are supported by the ManyToMany field.","title":"Methods"},{"location":"fields/many_to_many/#add_models","text":"Takes instance of the two relationship models and then saves it to the relationship table. 1 2 async def add_models ( model_instance_one : Model , model_instance_two : Model ) -> Model : Parameters: model_instance_one : An instance of the Model of the relation. model_instance_two : An instance of the main Model that calls the method.","title":"add_models"},{"location":"fields/many_to_many/#add","text":"Method called from an instance of one model and you must pass the instance of the other model. The relationship between the two will be saved. 1 async def add ( model_instance_one : Model ) -> Model : Parameters: model_instance_one : An instance of the Model of the relation.","title":"add"},{"location":"fields/many_to_many/#get_all","text":"Returns records from the other model of the relationship. 1 async def get_all () -> list [ Model ]:","title":"get_all"},{"location":"fields/many_to_many/#examples","text":"First, let's create our templates. Examples of using the methods explained above. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class User ( Model ): __tablename__ = 'users' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) name : str = Field . String () @classmethod def relationships ( cls ): cls . working_day = ManyToMany ( model = WorkingDay , model_relation = UsersWorkingDay ) class WorkingDay ( Model ): __tablename__ = 'working_days' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) week_day : str = Field . String () working_date : str = Field . String () @classmethod def relationships ( cls ): cls . users = ManyToMany ( model = User , model_relation = UsersWorkingDay ) class UsersWorkingDay ( Model ): __tablename__ = 'users_working_days' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) users : User = ForeignKey ( model = User , name_in_table_fk = 'id' ) working_days : WorkingDay = ForeignKey ( model = WorkingDay , name_in_table_fk = 'id' ) await User . create () await WorkingDay . create () await UsersWorkingDay . create () Can I use the Add and/or add_models method of the ManyToMany field to save a relationship: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 user = await User . save ( User ( name = 'Rich' )) user1 = await User . save ( User ( name = 'Elton' )) working_day = WorkingDay ( week_day = 'segunda' , working_date = '02/08/2021' ) working_day1 = WorkingDay ( week_day = 'ter\u00e7a' , working_date = '03/08/2021' ) working_day = await WorkingDay . save ( working_day ) working_day1 = await WorkingDay . save ( working_day1 ) await User . working_day . add_models ( working_day , user ) await WorkingDay . users . add_models ( user , working_day1 ) await user1 . working_day . add ( working_day ) await user1 . working_day . add ( working_day1 ) In lines 10, 11, 13 and 14 we are creating a record in the table UsersWorkingDay which is responsible for the Many to Many relationship. Do you notice a difference between lines 10-11 and 13-14? In the first ones it uses the attribute that is not only on the instance, it calls the from the models themselves, User and WorkingDay . In the last two it uses the instance attribute of a User , so it uses this instance to save in the relationship with the record that is passed as parameter. We also have the get_all method: 1 2 3 4 5 users : list [ User ] = await working_day . users . get_all () for u in users : print ( u . id ) # 1 and 2 print ( u . name ) # 'Rich' and 'Elton'","title":"Examples"},{"location":"fields/one_to_many/","text":"OneToMany This field is to represent the One to Many relationship. Let's look at some methods this field allows. The interface of a field OneToMany : 1 OneToMany ( model : Model , name_in_table_fk : str , name_relation : str ): Parameters: model : The other Model that will be used in the relationship. name_in_table_fk : The name of the attribute that will be FK in the other template. name_relation : The name of the database-level relationship. Methods Methods that are supported by the ManyToMany field. add M\u00e9todo que deve ser chamado de uma inst\u00e2ncia do modelo da lado do relacionamento N. 1 async def add ( model : Type [ Model ]) -> Model : Parameters: model : An instance of the Model of the relation. Examples First, let's create our models. Examples of using the methods explained above. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class City ( Model ): __tablename__ = 'cities' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) name : str = Field . String ( unique = True ) def relationships ( self ): self . persons = OneToMany ( model = Person , name_in_table_fk = 'city' , name_relation = 'person_city' ) class Person ( Model ): __tablename__ = 'persons' __db__ = db id_teste : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger () salary : int = Field . BigInteger () city : City = ForeignKey ( model = City , name_in_table_fk = 'id' ) await City . create () await Person . create () Now let's save a city and a person and then list the people of a certain city: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 city_cg = City ( name = \"Campina Grande\" ) person_1 = Person ( first_name = \"Rich\" , last_name = \"Carvalho\" , age = 22 , salary = 1250 , city = city_cg ) person_2 = Person ( first_name = \"Elton\" , last_name = \"Carvalho\" , age = 25 , salary = 1450 , city = city_cg ) city_cg = await City . save ( city_cg ) person_1 = await Person . save ( person_1 ) person_2 = await Person . save ( person_2 ) persons : list [ Person ] = await city . persons . get_all () # Return all the people in this city for person in persons : print ( person . first_name ) # Rich and Elton print ( person . city ) # Campina Grande and Campina Grande On lines 8 and 9 we are saving two people from the city of Campina Grande. And on line 11, I list the people in that city (they have relationship with that city). We also have the add method in the OneToMany field: 1 2 3 4 person_3 = Person ( first_name = \"Lucas\" , last_name = \"Andrade\" , age = 22 , salary = 1145 ) person_3 : Person = await city_cg . persons . add ( person_3 ) With that I can save a person and I already add in the city that I want to.","title":"OneToMany"},{"location":"fields/one_to_many/#onetomany","text":"This field is to represent the One to Many relationship. Let's look at some methods this field allows. The interface of a field OneToMany : 1 OneToMany ( model : Model , name_in_table_fk : str , name_relation : str ): Parameters: model : The other Model that will be used in the relationship. name_in_table_fk : The name of the attribute that will be FK in the other template. name_relation : The name of the database-level relationship.","title":"OneToMany"},{"location":"fields/one_to_many/#methods","text":"Methods that are supported by the ManyToMany field.","title":"Methods"},{"location":"fields/one_to_many/#add","text":"M\u00e9todo que deve ser chamado de uma inst\u00e2ncia do modelo da lado do relacionamento N. 1 async def add ( model : Type [ Model ]) -> Model : Parameters: model : An instance of the Model of the relation.","title":"add"},{"location":"fields/one_to_many/#examples","text":"First, let's create our models. Examples of using the methods explained above. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class City ( Model ): __tablename__ = 'cities' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) name : str = Field . String ( unique = True ) def relationships ( self ): self . persons = OneToMany ( model = Person , name_in_table_fk = 'city' , name_relation = 'person_city' ) class Person ( Model ): __tablename__ = 'persons' __db__ = db id_teste : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger () salary : int = Field . BigInteger () city : City = ForeignKey ( model = City , name_in_table_fk = 'id' ) await City . create () await Person . create () Now let's save a city and a person and then list the people of a certain city: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 city_cg = City ( name = \"Campina Grande\" ) person_1 = Person ( first_name = \"Rich\" , last_name = \"Carvalho\" , age = 22 , salary = 1250 , city = city_cg ) person_2 = Person ( first_name = \"Elton\" , last_name = \"Carvalho\" , age = 25 , salary = 1450 , city = city_cg ) city_cg = await City . save ( city_cg ) person_1 = await Person . save ( person_1 ) person_2 = await Person . save ( person_2 ) persons : list [ Person ] = await city . persons . get_all () # Return all the people in this city for person in persons : print ( person . first_name ) # Rich and Elton print ( person . city ) # Campina Grande and Campina Grande On lines 8 and 9 we are saving two people from the city of Campina Grande. And on line 11, I list the people in that city (they have relationship with that city). We also have the add method in the OneToMany field: 1 2 3 4 person_3 = Person ( first_name = \"Lucas\" , last_name = \"Andrade\" , age = 22 , salary = 1145 ) person_3 : Person = await city_cg . persons . add ( person_3 ) With that I can save a person and I already add in the city that I want to.","title":"Examples"},{"location":"fields/one_to_one/","text":"OneToOne This field is to represent the One To One relationship. Let's look at some methods this field allows. The interface of a field OneToOne : 1 OneToOne ( model : Model , name_relation : str ): Parameters: model : The Model that will be used in the relationship. name_relation : The name of the attribute that will be FK in the other model. Examples Examples for these types of relationships can be found here","title":"OneToOne"},{"location":"fields/one_to_one/#onetoone","text":"This field is to represent the One To One relationship. Let's look at some methods this field allows. The interface of a field OneToOne : 1 OneToOne ( model : Model , name_relation : str ): Parameters: model : The Model that will be used in the relationship. name_relation : The name of the attribute that will be FK in the other model.","title":"OneToOne"},{"location":"fields/one_to_one/#examples","text":"Examples for these types of relationships can be found here","title":"Examples"},{"location":"fields/relations/","text":"Relationships The relationships supported by DuckORM are basically of two types: One to Many and Many to One are supported by the ForeignKey field. Many to Many by creating a table and making use of the ForeignKey field to relate the two tables. One to One with the OneToOne field. Let's look at some examples of using these fields. OneToMany Set the ForeignKey field to use a One-to-Many relationship. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class City ( Model ): __tablename__ = 'cities' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) name : str = Field . String ( unique = True ) def relationships ( self ): self . persons = OneToMany ( model = Person , name_in_table_fk = 'city' , name_relation = 'person_city' ) class Person ( Model ): __tablename__ = 'persons' __db__ = db id_teste : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger () salary : int = Field . BigInteger () city : City = ForeignKey ( model = City , name_in_table_fk = 'id' ) await City . create () await Person . create () And with that, it will create the two tables and the persons table will have a field referencing the id field of the cities table. Note You may have also noticed the method relationships in the City class, but what will this do? This method doesn't make any changes to the database, just adds the persons: OneToMany field to the class, this field has some methods which are explained here . ManyToMany To create a Many to Many relationship we also use the ForeignKey field. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class User ( Model ): __tablename__ = 'users' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) name : str = Field . String () @classmethod def relationships ( cls ): cls . working_day = ManyToMany ( model = WorkingDay , model_relation = UsersWorkingDay ) class WorkingDay ( Model ): __tablename__ = 'working_days' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) week_day : str = Field . String () working_date : str = Field . String () @classmethod def relationships ( cls ): cls . users = ManyToMany ( model = User , model_relation = UsersWorkingDay ) class UsersWorkingDay ( Model ): __tablename__ = 'users_working_days' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) users : User = ForeignKey ( model = User , name_in_table_fk = 'id' ) working_days : WorkingDay = ForeignKey ( model = WorkingDay , name_in_table_fk = 'id' ) await User . create () await WorkingDay . create () await UsersWorkingDay . create () First we create the User and WorkingDay tables, they have a Many to Many relationship. To represent this relationship we create a third UsersWorkingDay table that has a reference to the PK of the other two tables, and thus creating the relationship. Note The relationships method in the two tables: User and WorkingDay are a little bit different from the previous example. Have the @classmethod signaling that it is a method of the class and not the instance, so it creates the users and working_day in both models. With that allowing some methods to be executed, like: User add a relationship with WorkingDay without using the UsersWorkingDay model. More examples can be seen here . OneToOne To represent the One to One relationship, just make use of the OneToOne field. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Person ( Model ): __tablename__ = 'persons' __db__ = db id_teste : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger () salary : int = Field . BigInteger () class Contact ( Model ): __tablename__ = 'contacts' __db__ = db id_person : Person = OneToOne ( model = Person , name_relation = 'person_contact' , field = 'id_person' ) phone : str = Field . String ( not_null = True ) await Person . create () await Contact . create () We create the Person table and the Contact table. We use the OneToOne field. This field will be the PK of that table, being of the same type as the table in the relationship, in this case the same type as the PK of the Person model. To save a Contact record: 1 2 3 4 5 person_1 = Person ( first_name = \"Rich\" , last_name = \"Ramalho\" , age = 22 , salary = 1250 ) contact_person_1 = Contact ( phone = \"XXXXXXXXX-XXXX\" , id_person = person_1 ) person_1 = await Person . save ( person_1 ) contact_person_1 = await Contact . save ( contact_person_1 ) And with that, DuckORM will save the relationship contact record with this person. What happens if I try to save the same person again in a another contact? 1 2 3 4 contact_error = Contact ( phone = \"YYYYYYYYY-YYYY\" , id_person = person_1 ) await Contact . save ( contact_error ) # This line will throw a duplicate # record exception.","title":"Relations"},{"location":"fields/relations/#relationships","text":"The relationships supported by DuckORM are basically of two types: One to Many and Many to One are supported by the ForeignKey field. Many to Many by creating a table and making use of the ForeignKey field to relate the two tables. One to One with the OneToOne field. Let's look at some examples of using these fields.","title":"Relationships"},{"location":"fields/relations/#onetomany","text":"Set the ForeignKey field to use a One-to-Many relationship. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class City ( Model ): __tablename__ = 'cities' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) name : str = Field . String ( unique = True ) def relationships ( self ): self . persons = OneToMany ( model = Person , name_in_table_fk = 'city' , name_relation = 'person_city' ) class Person ( Model ): __tablename__ = 'persons' __db__ = db id_teste : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger () salary : int = Field . BigInteger () city : City = ForeignKey ( model = City , name_in_table_fk = 'id' ) await City . create () await Person . create () And with that, it will create the two tables and the persons table will have a field referencing the id field of the cities table. Note You may have also noticed the method relationships in the City class, but what will this do? This method doesn't make any changes to the database, just adds the persons: OneToMany field to the class, this field has some methods which are explained here .","title":"OneToMany"},{"location":"fields/relations/#manytomany","text":"To create a Many to Many relationship we also use the ForeignKey field. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class User ( Model ): __tablename__ = 'users' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) name : str = Field . String () @classmethod def relationships ( cls ): cls . working_day = ManyToMany ( model = WorkingDay , model_relation = UsersWorkingDay ) class WorkingDay ( Model ): __tablename__ = 'working_days' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) week_day : str = Field . String () working_date : str = Field . String () @classmethod def relationships ( cls ): cls . users = ManyToMany ( model = User , model_relation = UsersWorkingDay ) class UsersWorkingDay ( Model ): __tablename__ = 'users_working_days' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) users : User = ForeignKey ( model = User , name_in_table_fk = 'id' ) working_days : WorkingDay = ForeignKey ( model = WorkingDay , name_in_table_fk = 'id' ) await User . create () await WorkingDay . create () await UsersWorkingDay . create () First we create the User and WorkingDay tables, they have a Many to Many relationship. To represent this relationship we create a third UsersWorkingDay table that has a reference to the PK of the other two tables, and thus creating the relationship. Note The relationships method in the two tables: User and WorkingDay are a little bit different from the previous example. Have the @classmethod signaling that it is a method of the class and not the instance, so it creates the users and working_day in both models. With that allowing some methods to be executed, like: User add a relationship with WorkingDay without using the UsersWorkingDay model. More examples can be seen here .","title":"ManyToMany"},{"location":"fields/relations/#onetoone","text":"To represent the One to One relationship, just make use of the OneToOne field. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Person ( Model ): __tablename__ = 'persons' __db__ = db id_teste : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger () salary : int = Field . BigInteger () class Contact ( Model ): __tablename__ = 'contacts' __db__ = db id_person : Person = OneToOne ( model = Person , name_relation = 'person_contact' , field = 'id_person' ) phone : str = Field . String ( not_null = True ) await Person . create () await Contact . create () We create the Person table and the Contact table. We use the OneToOne field. This field will be the PK of that table, being of the same type as the table in the relationship, in this case the same type as the PK of the Person model. To save a Contact record: 1 2 3 4 5 person_1 = Person ( first_name = \"Rich\" , last_name = \"Ramalho\" , age = 22 , salary = 1250 ) contact_person_1 = Contact ( phone = \"XXXXXXXXX-XXXX\" , id_person = person_1 ) person_1 = await Person . save ( person_1 ) contact_person_1 = await Contact . save ( contact_person_1 ) And with that, DuckORM will save the relationship contact record with this person. What happens if I try to save the same person again in a another contact? 1 2 3 4 contact_error = Contact ( phone = \"YYYYYYYYY-YYYY\" , id_person = person_1 ) await Contact . save ( contact_error ) # This line will throw a duplicate # record exception.","title":"OneToOne"},{"location":"models/","text":"Models With DuckORM it's easy to create your database models and get started right away. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from databases import Database from duck_orm.model import Model from duck_orm.sql import fields as Field db = Database ( 'sqlite:///example.db' ) await db . connect () class Person ( Model ): __tablename__ = 'persons' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger ( min_value = 18 ) salary : int = Field . BigInteger () So far you've only defined a template, but you haven't told DuckORM to create a table in the database, but it's easy to do that, just add a line of code: 1 await Person . create () Definition of fields And then just define the table fields . Basic Types For each table created, it must necessarily have a field with the attribute primary_key=True . And only one primary_key column is allowed. 1 2 3 4 5 6 7 8 9 class Person ( Model ): __tablename__ = 'persons' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger ( min_value = 18 ) salary : int = Field . BigInteger () Warning You should not assign more than one primary_key to more than one column in the same table. Dependencies DuckORM depends on databases library to connect to the database. Databases This parameter is it , and it is the instance create, bith your database URL string. This instance needs to be passed to the Model . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from databases import Database from duck_orm.model import Model from duck_orm.sql import fields as Field db = Database ( 'sqlite:///example.db' ) await db . connect () class Person ( Model ): __tablename__ = 'persons' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger ( min_value = 18 ) salary : int = Field . BigInteger () Tip You must create the databases instance only once and then use it for all models of your system, but nothing stops you from creating multiple instances Another important parameter is tablename , which is used to set the name of your Model in the database. if you want to use multiple databases . Table names Another important parameter is __tablename__ , which is used to set the name of your Model in the database. 1 2 3 4 5 6 7 8 9 class Person ( Model ): __tablename__ = 'persons' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger ( min_value = 18 ) salary : int = Field . BigInteger () Tip If you don't pass the __tablename__ attribute, the table name will be defined by the name of the Model . Example: In the case above, if the __tablename__ attribute was not passed, the name of the table would be person .","title":"Definition"},{"location":"models/#models","text":"With DuckORM it's easy to create your database models and get started right away. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from databases import Database from duck_orm.model import Model from duck_orm.sql import fields as Field db = Database ( 'sqlite:///example.db' ) await db . connect () class Person ( Model ): __tablename__ = 'persons' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger ( min_value = 18 ) salary : int = Field . BigInteger () So far you've only defined a template, but you haven't told DuckORM to create a table in the database, but it's easy to do that, just add a line of code: 1 await Person . create ()","title":"Models"},{"location":"models/#definition-of-fields","text":"And then just define the table fields .","title":"Definition of fields"},{"location":"models/#basic-types","text":"For each table created, it must necessarily have a field with the attribute primary_key=True . And only one primary_key column is allowed. 1 2 3 4 5 6 7 8 9 class Person ( Model ): __tablename__ = 'persons' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger ( min_value = 18 ) salary : int = Field . BigInteger () Warning You should not assign more than one primary_key to more than one column in the same table.","title":"Basic Types"},{"location":"models/#dependencies","text":"DuckORM depends on databases library to connect to the database.","title":"Dependencies"},{"location":"models/#databases","text":"This parameter is it , and it is the instance create, bith your database URL string. This instance needs to be passed to the Model . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from databases import Database from duck_orm.model import Model from duck_orm.sql import fields as Field db = Database ( 'sqlite:///example.db' ) await db . connect () class Person ( Model ): __tablename__ = 'persons' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger ( min_value = 18 ) salary : int = Field . BigInteger () Tip You must create the databases instance only once and then use it for all models of your system, but nothing stops you from creating multiple instances Another important parameter is tablename , which is used to set the name of your Model in the database. if you want to use multiple databases .","title":"Databases"},{"location":"models/#table-names","text":"Another important parameter is __tablename__ , which is used to set the name of your Model in the database. 1 2 3 4 5 6 7 8 9 class Person ( Model ): __tablename__ = 'persons' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger ( min_value = 18 ) salary : int = Field . BigInteger () Tip If you don't pass the __tablename__ attribute, the table name will be defined by the name of the Model . Example: In the case above, if the __tablename__ attribute was not passed, the name of the table would be person .","title":"Table names"},{"location":"models/methods/","text":"Methods Here we will show some methods that the Model has and we will also see how to use each one of them. To run the examples run using ipython . get_name Method that returns the name of the Model in the database. And if the __tablename__ attribute has not been assigned in the Model , then this method will return the class name in lowercase. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Person ( Model ): __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) Person . get_name () # will return 'person'. class Client ( Model ): __tablename__ = 'clients' __db__ = db # definitions of fields ... Client . get_name () # Will return 'clients'. create Asynchronous method that will create the table that represents the Model in the database. It should always be used before trying to save, search or delete an object of the Model . 1 2 3 4 5 6 7 8 9 10 11 class Person ( Model ): __tablename__ = 'persons' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger ( min_value = 18 ) salary : int = Field . BigInteger () await Person . create () save 1 save ( model : Model ) -> Model : Asynchronous method that will save an object to the table in the database. Parameters: model : Model instance with fields filled. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ... person_1 = Person ( first_name = \"Teste 1\" , last_name = \"teste lastname\" , age = 19 , salary = 5000 ) person_2 = Person ( first_name = \"Teste 2\" , last_name = \"teste lastname\" , age = 25 , salary = 4000 ) person_3 = Person ( first_name = \"Teste 3\" , last_name = \"teste lastname\" , age = 22 , salary = 2500 ) person_1 = await Person . save ( person_1 ) person_2 = await Person . save ( person_2 ) person_3 = await Person . save ( person_3 ) person_1 . id # 1 person_1 . first_name # Teste 1 person_1 . age # 19 person_2 . id # 2 person_2 . first_name # Teste 2 person_2 . age # 25 person_3 . id # 3 person_3 . first_name # Teste 3 person_3 . age # 22 find_all 1 2 3 4 5 6 find_all ( fields_includes : List [ str ] = [], fields_excludes : List [ str ] = [], conditions : List [ Condition ] = [], limit : int = None ) -> List [ Model ] Asynchronous method that retrieves all objects persisted in a table in the database. Parameters: fields_includes : The Model fields that are to be retrieved. fields_excludes : The Model fields that should not be retrieved. conditions : Conditions for filtering objects. limit : The maximum limit of objects that must be retrieved. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ... from duck_orm.sql.condition import Condition persons : list [ Person ] = await Person . find_all ( fields_includes = [ 'first_name' , 'age' , 'salary' ], # I could have left this parameter blank as it is no longer in # fields_includes. fields_excludes = [ 'id' ], conditions = [ Condition ( 'first_name' , 'LIKE' , 'Teste%' ), Condition ( 'salary' , '>=' , 2600 ) ] ) for person in persons : print ( person . id ) # None in all. print ( person . first_name ) # Teste 1, Teste 2 print ( person . age ) # 19, 25 print ( person . salary ) # 5000, 4000 find_one 1 2 3 4 5 find_one ( fields_includes : List [ str ] = [], fields_excludes : List [ str ] = [], conditions : List [ Condition ] = [], ) -> List [ Model ] Asynchronous method that retrieves only one object persisted in a table in the database. If you pass the filtering condition by the key field, this method can be used as a find by id. Parameters: fields_includes : The Model fields that are to be retrieved. fields_excludes : The Model fields that should not be retrieved. conditions : The conditions for filtering the object. 1 2 3 4 5 6 7 8 9 10 11 person : Person = await Person . find_one ( conditions = [ Condition ( 'id' , '=' , 1 ) ] ) print ( person . id ) # 1 print ( person . first_name ) # Teste 1 print ( person . last_name ) # teste lastname print ( person . age ) # 19 print ( person . salary ) # 5000 find_all_tables 1 async def find_all_tables (): Asynchronous method that returns all table names persisted in the database. 1 print ( await Person . find_all_tables ()) update 1 async def update ( ** kwargs ) -> Model : Asynchronous method to alter a record persisted in the database. Parameters: kwargs : A dictionary with the Model fields that must be changed and its new values. 1 2 3 4 5 6 7 8 9 10 11 12 13 person : Person = await Person . find_one ( conditions = [ Condition ( 'id' , '=' , 1 ) ] ) print ( person . id ) # 1 person : Person = await person . update ( first_name = 'Teste 1 UPDATE' , age = 22 ) print ( person . id ) # 1 print ( person . first_name ) # Teste 1 UPDATE print ( person . age ) # 22 delete 1 async def delete ( conditions : List [ Condition ]): Asynchronous method that deletes a record from the database. Parameters: conditions : The conditions for filtering the record(s). 1 2 3 4 5 person : Person = await Person . delete ( conditions = [ Condition ( 'id' , '=' , 1 ) ] )","title":"Methods"},{"location":"models/methods/#methods","text":"Here we will show some methods that the Model has and we will also see how to use each one of them. To run the examples run using ipython .","title":"Methods"},{"location":"models/methods/#get_name","text":"Method that returns the name of the Model in the database. And if the __tablename__ attribute has not been assigned in the Model , then this method will return the class name in lowercase. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Person ( Model ): __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) Person . get_name () # will return 'person'. class Client ( Model ): __tablename__ = 'clients' __db__ = db # definitions of fields ... Client . get_name () # Will return 'clients'.","title":"get_name"},{"location":"models/methods/#create","text":"Asynchronous method that will create the table that represents the Model in the database. It should always be used before trying to save, search or delete an object of the Model . 1 2 3 4 5 6 7 8 9 10 11 class Person ( Model ): __tablename__ = 'persons' __db__ = db id : int = Field . Integer ( primary_key = True , auto_increment = True ) first_name : str = Field . String ( unique = True ) last_name : str = Field . String ( not_null = True ) age : int = Field . BigInteger ( min_value = 18 ) salary : int = Field . BigInteger () await Person . create ()","title":"create"},{"location":"models/methods/#save","text":"1 save ( model : Model ) -> Model : Asynchronous method that will save an object to the table in the database. Parameters: model : Model instance with fields filled. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ... person_1 = Person ( first_name = \"Teste 1\" , last_name = \"teste lastname\" , age = 19 , salary = 5000 ) person_2 = Person ( first_name = \"Teste 2\" , last_name = \"teste lastname\" , age = 25 , salary = 4000 ) person_3 = Person ( first_name = \"Teste 3\" , last_name = \"teste lastname\" , age = 22 , salary = 2500 ) person_1 = await Person . save ( person_1 ) person_2 = await Person . save ( person_2 ) person_3 = await Person . save ( person_3 ) person_1 . id # 1 person_1 . first_name # Teste 1 person_1 . age # 19 person_2 . id # 2 person_2 . first_name # Teste 2 person_2 . age # 25 person_3 . id # 3 person_3 . first_name # Teste 3 person_3 . age # 22","title":"save"},{"location":"models/methods/#find_all","text":"1 2 3 4 5 6 find_all ( fields_includes : List [ str ] = [], fields_excludes : List [ str ] = [], conditions : List [ Condition ] = [], limit : int = None ) -> List [ Model ] Asynchronous method that retrieves all objects persisted in a table in the database. Parameters: fields_includes : The Model fields that are to be retrieved. fields_excludes : The Model fields that should not be retrieved. conditions : Conditions for filtering objects. limit : The maximum limit of objects that must be retrieved. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ... from duck_orm.sql.condition import Condition persons : list [ Person ] = await Person . find_all ( fields_includes = [ 'first_name' , 'age' , 'salary' ], # I could have left this parameter blank as it is no longer in # fields_includes. fields_excludes = [ 'id' ], conditions = [ Condition ( 'first_name' , 'LIKE' , 'Teste%' ), Condition ( 'salary' , '>=' , 2600 ) ] ) for person in persons : print ( person . id ) # None in all. print ( person . first_name ) # Teste 1, Teste 2 print ( person . age ) # 19, 25 print ( person . salary ) # 5000, 4000","title":"find_all"},{"location":"models/methods/#find_one","text":"1 2 3 4 5 find_one ( fields_includes : List [ str ] = [], fields_excludes : List [ str ] = [], conditions : List [ Condition ] = [], ) -> List [ Model ] Asynchronous method that retrieves only one object persisted in a table in the database. If you pass the filtering condition by the key field, this method can be used as a find by id. Parameters: fields_includes : The Model fields that are to be retrieved. fields_excludes : The Model fields that should not be retrieved. conditions : The conditions for filtering the object. 1 2 3 4 5 6 7 8 9 10 11 person : Person = await Person . find_one ( conditions = [ Condition ( 'id' , '=' , 1 ) ] ) print ( person . id ) # 1 print ( person . first_name ) # Teste 1 print ( person . last_name ) # teste lastname print ( person . age ) # 19 print ( person . salary ) # 5000","title":"find_one"},{"location":"models/methods/#find_all_tables","text":"1 async def find_all_tables (): Asynchronous method that returns all table names persisted in the database. 1 print ( await Person . find_all_tables ())","title":"find_all_tables"},{"location":"models/methods/#update","text":"1 async def update ( ** kwargs ) -> Model : Asynchronous method to alter a record persisted in the database. Parameters: kwargs : A dictionary with the Model fields that must be changed and its new values. 1 2 3 4 5 6 7 8 9 10 11 12 13 person : Person = await Person . find_one ( conditions = [ Condition ( 'id' , '=' , 1 ) ] ) print ( person . id ) # 1 person : Person = await person . update ( first_name = 'Teste 1 UPDATE' , age = 22 ) print ( person . id ) # 1 print ( person . first_name ) # Teste 1 UPDATE print ( person . age ) # 22","title":"update"},{"location":"models/methods/#delete","text":"1 async def delete ( conditions : List [ Condition ]): Asynchronous method that deletes a record from the database. Parameters: conditions : The conditions for filtering the record(s). 1 2 3 4 5 person : Person = await Person . delete ( conditions = [ Condition ( 'id' , '=' , 1 ) ] )","title":"delete"}]}